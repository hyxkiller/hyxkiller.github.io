---
title: 数组方法知识点
date: 2019-04-08 15:16:13
tags: 前端
categories: 前端
---

### forEach  
无返回值，不支持链式调用。  
可改变数组中引用类型的数据，不可改变值类型的数据。
```
var arr1 = [
    {name:'A',age:16},
    {name:'B',age:17}
];
var arr2 = [1,2,3];

arr1.forEach(item => { 
    item.age = item.age + 1
}); 
// arr1 -> [{name:'A',age:17},{name:'B',age:18}]

arr2.forEach(item => {
    item = item * 2
});
// arr2 -> [1,2,3]
```

### map      
原始数组无变化，必须有return(jsx中数组循环返回Dom都用map的原因)。     
需要注意的是，如果做过滤处理，是行不通的。
```
let arr = [1,2,3,4,5].map(item => { if(item > 3) return item })
// arr -> [undefined, undefined, undefined, 4, 5]
```

### filter   
筛选过滤

### some  
返回值为bool

### every    
返回值为bool

### sort     
与map、filter不同的一点是，会改变原数组。   
按Unicode码排序。

### findIndex    
可中断遍历，并返回相应需求的下标。
```
let arr = [{ name:'A', age:16 },{ name:'B', age:17 },{ name:'C', age:18 }]
let index = arr.findIndex(item => item.age > 16 );
// 1
```

### find     
可中断遍历，并返回符合条件的整个元素。
```
let arr = [{name:'A',age:16},{name:'B',age:17},{    name:'C',age:18}]
let item = arr.find(item => item.age > 16 );
// {name:'B',age:17}
```

### from
从一个类似数组或可迭代对象中创建一个新的数组实例(伪数组对象:拥有一个 length 属性和若干索引属性的任意对象;可迭代对象:可以获取对象中的元素,如 Map和 Set 等)
```
// String
Array.from('foo'); 
// ["f", "o", "o"]

// Set
let s = new Set(['foo', window]); 
Array.from(s)
// ["foo", window]

// Map
let m = new Map([[1, 2], [2, 4], [4, 8]]);
Array.from(m); 
// [[1, 2], [2, 4], [4, 8]]
```

### copyWithin
浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度
> arr.copyWithin(target, start, end);
> target: 复制到该数组的索引值(必须)
> start: 复制元素的起始位置(可选)
> end: 复制元素的结束为止(可选)

```
let number1 = [1, 2, 3, 4, 5];
number1.copyWithin(2); // [1, 2, 1, 2, 3]
number1.copyWithin(-2, -3, -1); //  [1, 2, 1, 1, 2] (会改变原数组)
```

### flat
按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回(默认值为1)
```
let arr = [1, 2, [3, 4, [5, 6]]];
arr.flat(); // [1, 2, 3, 4, [5, 6]]
arr.flat(2); // [1, 2, 3, 4, 5, 6]
arr.flat(Infinity); // [1, 2, 3, 4, 5, 6]
let arr2 = [1, 2, , 4, 5];
arr2.flat(); // [1, 2, 4, 5] (移除数组的空项)
```

### flatMap
使用映射函数映射每个元素，然后将结果压缩成一个新数组，与map和深度值为1的flat几乎相同，在合并成一种方法的效率略高
```
ler arr = ['hello', '', 'world'];
arr.map(e => e.split('')); // [["h", "e", "l", "l", "o"], [''], ["w", "o", "r", "l", "d"]]
arr.flatMap(e => e.split('')); // ["h", "e", "l", "l", "o", "w", "o", "r", "l", "d"]
```

### includes
用来判断一个数组是否包含一个指定的值，返回值bool。
> arr.includes(value, fromIndex)
> fromIndex 从fromIndex索引开始查找(可选)

### lastIndexOf
返回指定元素在数组中的最后一个的索引，不存在返回-1
> arr.lastIndexOf(searchValue, fromIndex = arr.length - 1)
> fromIndex 从fromIndex索引逆向查找(可选)，

```
let arr = [1, 3, 7, 1]
arr.lastIndexOf(1);    // 3
arr.lastIndexOf(1, 2);   // 0
arr.lastIndexOf(1, -1);   // 3
```

### reduce
对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值
> arr.reduce(callback, initialValue)
> callback(accumulator, currentValue, index, array)
> accumulator:上一次累计返回的值
> currentValue:当前正在处理的元素
> index:正在处理元素的索引(可选)
> array:被调用的map数组(可选)

```
let arr = [1, 20, 100, 101]
arr.reduce((a, b) => a + b); // 222(1+20+100+101)
arrc.reduce((a,b) => a+b, 10) // 232(10+1+20+100+101)
```

### entries
返回一个Array Iterator对象
```
let arrv = [1, 'asd', true];
let iterator = arrv.entries();
for(let e of iterator){
    console.log(e)
}
// [0, 1]
// [1, 'asd']
// [2, true]
```

### Set  
+ 只可对值类型的数据进行去重
```
let mySet = new Set();
mySet.add(1); // Set(1) {1}
mySet.add(2); // Set(2) {1, 2}
mySet.add(2); // Set(2) {1, 2} // 值类型唯一
mySet.add('text'); 
[...mySet] // [1, 2, 'text']

mySet.add({ name:'ha', age:18 });
mySet.add({ name:'ha', age:18 });
[...mySet] // [1, 2, 'text', { name:'ha', age:18 }, { name:'ha', age:18 }]
```
+ 引用类型去重方案
```
Lodash的_.uniqWith()方法
```

###  数组的哪些API会改变原数组？
1. 修改原数组的API有: ``splice, reverse, fill, copyWithin, sort, push, pop, unshift, shift``
2. 不修改原数组的API有: ``slice, map, forEach, every, filter, reduce, entry, entries, find``
