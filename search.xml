<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo集成GitHub Actions]]></title>
    <url>%2F2022%2F03%2F28%2FHexo%E9%9B%86%E6%88%90GitHub%20Actions%2F</url>
    <content type="text"><![CDATA[本文主要讲解用Hexo做的博客系统如何通过GitHub Actions实现CI/CD。 工作原理简单说下GitHub Actions的工作原理：在项目根目录下创建.github/workflows文件夹，然后在该文件夹下创建一个后缀名为.yml的配置文件，当我们通过某一个动作触发GitHub Actions时，该配置文件会被解析，并执行相应的操作。一个工作流程workflow可以有多个任务job，每个任务又能分成几个步骤step，每个步骤可以一次执行多个命令action。 实现过程 在GitHub个人设置Settings/Developer settings下的Personal access tokens新建一个ACCESS_TOKEN 然后到项目下的settings/Secrets/Actions下新建一个repo secrect，值为第一步创建好的值，key为ACCESS_TOKEN`（随意起，但必须与.yml中的一致） 还是使用双分支的形式处理，因为最终GitHubPage项目的主分支要的还是hexo g出来的html 配置.yml文件，内容如下，可见[这里](https://github.com/hyxkiller/hyxkiller.github.io/blob/action-source/.github/workflows/deploy.yml)： 12345678910111213141516171819202122232425262728293031323334353637383940name: blogon: push: branches: - action-sourcejobs: build-and-deploy: runs-on: ubuntu-latest env: TZ: Asia/Shanghai steps: - name: Checkout source uses: actions/checkout@v2 with: submodules: true - name: Setup Node.js uses: actions/setup-node@v1 with: node-version: &apos;12.x&apos; - name: Install dependencies &amp; Generate static files run: | node -v npm i -g hexo-cli npm i hexo clean hexo g - name: Deploy to Github Pages env: GIT_NAME: your git name GIT_EMAIL: your git email REPO: your repo name ACCESS_TOKEN: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; run: | cd ./public &amp;&amp; git init &amp;&amp; git add . git config --global user.name $GIT_NAME git config --global user.email $GIT_EMAIL git commit -m &quot;Github Actions Auto Builder at `date +&quot;%Y-%m-%d %H:%M&quot;`&quot; git push --force --quiet &quot;https://$ACCESS_TOKEN@$REPO&quot; master:master 将改动push到github后，在Github的Actions下可见此次工作流的执行过程。 过程解释 name：指当前workflow的名称 on：指定触发workflow的条件，通常是某些事件，我们这里是当有push操作时执行;branches是指定某个分支push才执行 jobs：表示要执行的一项或多项任务，我们这里要做的就是把博客内容通过hexo g的方式推到master分支上 runs-on：指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。 123ubuntu-latest，ubuntu-18.04或ubuntu-16.04windows-latest，windows-2019或windows-2016macOS-latest或macOS-10.14 steps：指定node版本 -&gt; 通过hexo的一系列命令最后生成相应的html文件 -&gt; 将生成的文件推到远程仓库的master上 需要注意的是ACCESS_TOKEN: $，即为之前创建的密钥，常量命名需保持一致 至此，你已经可以再你的Github Page上开心的看到你的杰作了，以后更新博客只需要写完文件后push到该分支即可。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配]]></title>
    <url>%2F2019%2F05%2F21%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[一、理解几个长度单位概念英寸(inch)一般用英寸描述屏幕的物理大小，是屏幕对角线长度，如电脑显示器的13.3、15.4，手机显示器的4.8、5.7等使用的单位都是英寸。 PPI(pixel per inch)每英寸包括的像素数。可以描述屏幕和图片的清晰度，数值越高越清晰。PPI计算方法:以IPhone6举例，ppi = ，每英寸约含有326个物理像素点。 DPI(dot per inch)每英寸包括的点数。这个点是一个抽象的单位，可以是屏幕像素点、图片像素点、打印机的墨点。 DP(device independent pixels)设备独立像素。iPhone X的设备独立像素为375×812，IPhone 6p/7p/8p为414×736，IPhone 6/7/8为375×667，IPhone5/5s/5c/SE为320×568。 DPR(device pixel ratio)物理像素和设备独立像素的比值。浏览器通过window.devicePixelRatio获取dpr；css通过min-device-pixel-ratio区分dpr；在RN中，通过PixelRatio.get()获取dpr。iPhone X/XS/XS Max/6p/7p/8p的dpr为3，IPhone 6/7/8/5/5s/5c/SE/XR为2。 px、pt、dp相互转换在iOS、Android、RN包括Flutter的开发中单位样式都使用的是设备独立像素。整理来讲，iOS为pt，其他是dp。dp/pt和px：12px = dp * ppi / 160dp = px * 160 / ppi 二、视口布局视口，视觉视口，理想视口 布局视口(layout viewport)：网页的布局的基准窗口，PC端就是浏览器当前窗口大小，移动端会赋予一个默认值为980px。 视觉视口(visual viewport)：用户通过屏幕看到的区域。 理想视口(ideal viewport)：网站页面在移动端展示的理想大小。 Meta viewport&lt;meta&gt;元素表示那些不能由其它HTML元相关元素之一表示的任何元数据信息，它可以告诉浏览器如何解析页面。1&lt;meta name="viewport" content="width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;"&gt; 参数含义： value 可能值 描述 width 正整数或device-width 以pixels（像素）为单位， 定义布局视口的宽度。 height 正整数或device-height 以pixels（像素）为单位， 定义布局视口的高度。 initial-scale 0.0 - 10.0 定义页面初始缩放比率。 minimum-scale 0.0 - 10.0 定义缩放的最小值；必须小于或等于maximum-scale的值。 maximum-scale 0.0 - 10.0 定义缩放的最大值；必须大于或等于minimum-scale的值。 user-scalable 一个布尔值（yes或者no） 如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。 移动端适配由于设置了width=device-width和initial-scale=1，相当于理想视口等于布局视口（其中：initial-scale = 理想视口宽度 / 视觉视口宽度）。这时，一个css像素就等于一个设备独立像素。 获取浏览器大小 window.innerHeight：获取浏览器视觉视口高度（包括垂直滚动条）。 window.outerHeight：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。 window.screen.Height：获取获屏幕取理想视口高度，这个数值是固定的，设备的分辨率/设备像素比 window.screen.availHeight：浏览器窗口可用的高度。 document.documentElement.clientHeight：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。 document.documentElement.offsetHeight：包括内边距、滚动条、边框和外边距。 document.documentElement.scrollHeight：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与clientHeight相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。 三、 1px问题12345678910111213.border &#123; border: 1px solid #000;&#125;@media screen and (-webkit-min-device-pixel-ratio: 2)&#123; .border &#123; border: 0.5px solid #000; &#125; &#125;@media screen and (-webkit-min-device-pixel-ratio: 3)&#123; .border &#123; border: 0.333333px solid #000; &#125; &#125; 四、移动端适配方案vw+rem方案 vw: 1vw = window.innerWidth * 0.01 vh: 1vh = window.innerHeight * 0.01 vmin: vw和vh中的较小值 vmax: vw和vh中的较大值 整个屏幕宽为100vw，如果设计稿以iPhone 5为基准即320px，那么1px对应100/320=0.3125vw，100px对应0.3125*100=31.25vw，然后设置html的font-size为31.25vw，那么1rem为31.25vw&lt;=&gt;100px。同理，iPhone 6的话根元素html的font-size为26.6666667vw。 五、适配刘海屏等viewport-fit1&lt;meta name="viewport" content="viewport-fit=cover"&gt; contain/auto: 可视窗口完全包含网页内容 cover: 网页内容完全覆盖可视窗口 env, constant将顶部和底部合理放在安全区内，iOS11新增了两个CSS函数env(iOS &gt;= 11.2)、constant(iOS &lt; 11.2)，用于设定安全区域与边界的距离。函数内部可以是以下4个常量： safe-area-inset-left: 安全区域距离左边边界距离 safe-area-inset-right: 安全区域距离右边边界距离 safe-area-inset-top: 安全区域距离顶部边界距离 safe-area-inset-bottom: 安全区域距离底部边界距离 1234body&#123; padding-top: constant(safe-area-inset-top); padding-top: env(safe-area-inset-top);&#125; 横屏适配js检测通过orientationchange事件来监听设备是否旋转，配合window.orientation属性判断当前是横屏还是竖屏，以便执行不同的操作。12345678910window.addEventListener("orientationchange", () =&gt; &#123; if (window.orientation === 180 || window.orientation === 0) &#123; // 正常方向或屏幕旋转180度(0: 竖屏模式/portrait, 180: 上线互换的竖屏) console.log('竖屏'); &#125;; if (window.orientation === 90 || window.orientation === -90 )&#123; // 屏幕顺时钟旋转90度或屏幕逆时针旋转90度 console.log('横屏'); &#125; &#125;); css检测123456@media screen and (orientation: portrait) &#123; /*竖屏...*/&#125; @media screen and (orientation: landscape) &#123; /*横屏...*/&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[travis自动部署个人服务器]]></title>
    <url>%2F2019%2F05%2F08%2Ftravis%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[写在前面自动部署githubio后，当然也得实现自动部署个人服务器。首先，我提前先在服务器写好了nginx配置文件，将根路由指向固定目录下的文件。 实现原理坑看了网上好多博客教程，大概意思是把本地的公钥放到服务器，然后会通过travis encrypt加密公钥文件，在.travis.yml里会自动生成一段openssl的代码，但我最终没有成功。我的想法是应该是travis部署服务和个人服务器公钥之间的关系，因为这样按那些做法做的话，如果换一台电脑还得再匹配出一份密钥。 最终通过sshpass解决问题 首先通过travis给服务器的用户名和密码加密(因为直接暴露ssh的用户名密码不安全，而travis提供了加密变量的功能) 12travis encrypt DEPLOY_USER=yourusernametravis encrypt DEPLOY_PASS=yourpassword 然后把生成的哈希填到.travis.yml文件的env里 1234env: global: - secure: "" - secure: "" 之后脚本就可以使用变量了 123after_success: - export SSHPASS=$DEPLOY_PASS - sshpass -e scp -o stricthostkeychecking=no -r public username:IP:/路径 stricthostkeychecking=no是绕过ssh远程主机公钥检查， -r是上传文件夹的参数]]></content>
      <categories>
        <category>travis</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>travis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[travis自动部署github]]></title>
    <url>%2F2019%2F04%2F29%2Ftravis%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2github%2F</url>
    <content type="text"><![CDATA[写在前面任何一个项目的手动部署都会让开发觉得很繁琐，所以学一点CI/CD的简单知识也有一定必要。经过调研发现和github集成较好的是travis这一工具。当然也是为了解决换了电脑还要重新配置hexo那一套东西的问题。至于travis与github的项目关联就不再赘述，网上很多博客都有介绍。主要说一下配置过程中遇到的问题。 整体思路因为hexo集成到github的master分支的是public下的静态文件，所以采用另一分支保存hexo配置及.travis.yml的方案，这样随时随地登录github就可以修改博客内容并提交一次commit，告知travis执行新的部署工作。 可能遇到的问题本地可以生成静态文件，travis执行hexo g出现No layout的情况(另一表现是生成的html都是空白的)原因是使用next主题，但是没有把next主题的文件push到github，因为在本地装这个主题的时候next文件夹内部也有.git, .gitignore文件，这时候在github里这个文件是点不开的，需要执行以下命令：12rm -rf .git .gitignoregit rm -r --cached themes/next // 删除next的本地缓存 然后重新提交，即可通过travis正常生成静态文件。 服务器无法下载travis 执行gem sources -l, 如果结果是https://rubygems.org/, 会有源的问题，先换源 1gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ 然后更新gem 1gem update --system 然后按照网上很多人的博客是可以进行第四步下载了，但我这遇到一个大概意思是服务器ruby版本是2.0，但下载travis 的时候用的是1.10版本的ruby的问题，之后装了一些包才整好。 1yum install -y ruby-devel rubygems 下载travis 1gem install travis 密钥名字的问题在执行将public文件push到master分支的过程中，需要在地址前写用于github和travis匹配的key，这里的名字是设置在travis环境变量里的变量名！1git push --force --quiet &quot;https://$&#123;GIT_REPO&#125;@$&#123;GH_REF&#125;&quot; master:master master commit树被清空12345678after_success: - cd ./public - git init - git config user.name &quot;yourname&quot; - git config user.email &quot;your email&quot; - git add . - git commit -m &quot;update&quot; - git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master 如果是这样执行，每次都是将public目录下的文件重新生成了一个git项目，然后强制覆盖提交到了master分支下，这就是问题的所在。需要做以下修改：123456789101112after_success: - git clone https://$&#123;GH_REF&#125; .deploy_git - cd .deploy_git - git checkout master - cd ../ - mv .deploy_git/.git/ ./public/ - cd ./public - git config user.name &quot;yourname&quot; - git config user.email &quot;your email&quot; - git add . - git commit -m &quot;Travis CI Auto Builder&quot; - git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master 先将博客项目clone到本地的.deploy_git目录下（目录名可自定义）,然后切换到master分支，将master分支下的.git目录拷贝到了public目录下，接着继续后面的commit操作。]]></content>
      <categories>
        <category>travis</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>travis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何处理循环异步问题]]></title>
    <url>%2F2019%2F04%2F15%2F%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BE%AA%E7%8E%AF%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[场景后台管理项目一般都需要很多数据处理，遇到一个场景：管理员可以上传0–+∞图片类型+图片的场景，将数据存起来后不知道会上传多少组数据，调多少次上传图片的接口(因为这个接口会返回各个文件的id，之后在组合id调上传信息的接口)，就想到将最后的数组循环调用然后等返回值，就设计到forEach不能和await共用的问题。 期初以为是async和await无法真正做到这种异步问题，就用Promise包了一层又一层，结果还是有问题。 自己当时的解法最后想了一个解法，在保存数据的数组外定义一个变量，每次循环变量+1，循环内判断当此变量等于数组的长度时，将所有数据组装调上传信息的接口。 原因forEach只支持同步代码，只是简单的执行一下回调函数，不会处理异步代码。 其他解法for…of (迭代器的一种实现，通过迭代器的方式遍历1234567async function test() &#123; let arr = [1, 2, 3]; for(const val of arr)&#123; const res = await 请求(val) console.log(res); &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组方法知识点]]></title>
    <url>%2F2019%2F04%2F08%2F%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[forEach无返回值，不支持链式调用。可改变数组中引用类型的数据，不可改变值类型的数据。123456789101112131415var arr1 = [ &#123;name:'A',age:16&#125;, &#123;name:'B',age:17&#125;];var arr2 = [1,2,3];arr1.forEach(item =&gt; &#123; item.age = item.age + 1&#125;); // arr1 -&gt; [&#123;name:'A',age:17&#125;,&#123;name:'B',age:18&#125;]arr2.forEach(item =&gt; &#123; item = item * 2&#125;);// arr2 -&gt; [1,2,3] map原始数组无变化，必须有return(jsx中数组循环返回Dom都用map的原因)。需要注意的是，如果做过滤处理，是行不通的。12let arr = [1,2,3,4,5].map(item =&gt; &#123; if(item &gt; 3) return item &#125;)// arr -&gt; [undefined, undefined, undefined, 4, 5] filter筛选过滤 some返回值为bool every返回值为bool sort与map、filter不同的一点是，会改变原数组。按Unicode码排序。 findIndex可中断遍历，并返回相应需求的下标。123let arr = [&#123; name:'A', age:16 &#125;,&#123; name:'B', age:17 &#125;,&#123; name:'C', age:18 &#125;]let index = arr.findIndex(item =&gt; item.age &gt; 16 );// 1 find可中断遍历，并返回符合条件的整个元素。123let arr = [&#123;name:'A',age:16&#125;,&#123;name:'B',age:17&#125;,&#123; name:'C',age:18&#125;]let item = arr.find(item =&gt; item.age &gt; 16 );// &#123;name:'B',age:17&#125; from从一个类似数组或可迭代对象中创建一个新的数组实例(伪数组对象:拥有一个 length 属性和若干索引属性的任意对象;可迭代对象:可以获取对象中的元素,如 Map和 Set 等)12345678910111213// StringArray.from('foo'); // ["f", "o", "o"]// Setlet s = new Set(['foo', window]); Array.from(s)// ["foo", window]// Maplet m = new Map([[1, 2], [2, 4], [4, 8]]);Array.from(m); // [[1, 2], [2, 4], [4, 8]] copyWithin浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度 arr.copyWithin(target, start, end);target: 复制到该数组的索引值(必须)start: 复制元素的起始位置(可选)end: 复制元素的结束为止(可选) 123let number1 = [1, 2, 3, 4, 5];number1.copyWithin(2); // [1, 2, 1, 2, 3]number1.copyWithin(-2, -3, -1); // [1, 2, 1, 1, 2] (会改变原数组) flat按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回(默认值为1)123456let arr = [1, 2, [3, 4, [5, 6]]];arr.flat(); // [1, 2, 3, 4, [5, 6]]arr.flat(2); // [1, 2, 3, 4, 5, 6]arr.flat(Infinity); // [1, 2, 3, 4, 5, 6]let arr2 = [1, 2, , 4, 5];arr2.flat(); // [1, 2, 4, 5] (移除数组的空项) flatMap使用映射函数映射每个元素，然后将结果压缩成一个新数组，与map和深度值为1的flat几乎相同，在合并成一种方法的效率略高123ler arr = ['hello', '', 'world'];arr.map(e =&gt; e.split('')); // [["h", "e", "l", "l", "o"], [''], ["w", "o", "r", "l", "d"]]arr.flatMap(e =&gt; e.split('')); // ["h", "e", "l", "l", "o", "w", "o", "r", "l", "d"] includes用来判断一个数组是否包含一个指定的值，返回值bool。 arr.includes(value, fromIndex)fromIndex 从fromIndex索引开始查找(可选) lastIndexOf返回指定元素在数组中的最后一个的索引，不存在返回-1 arr.lastIndexOf(searchValue, fromIndex = arr.length - 1)fromIndex 从fromIndex索引逆向查找(可选)， 1234let arr = [1, 3, 7, 1]arr.lastIndexOf(1); // 3arr.lastIndexOf(1, 2); // 0arr.lastIndexOf(1, -1); // 3 reduce对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值 arr.reduce(callback, initialValue)callback(accumulator, currentValue, index, array)accumulator:上一次累计返回的值currentValue:当前正在处理的元素index:正在处理元素的索引(可选)array:被调用的map数组(可选) 123let arr = [1, 20, 100, 101]arr.reduce((a, b) =&gt; a + b); // 222(1+20+100+101)arrc.reduce((a,b) =&gt; a+b, 10) // 232(10+1+20+100+101) entries返回一个Array Iterator对象12345678let arrv = [1, 'asd', true];let iterator = arrv.entries();for(let e of iterator)&#123; console.log(e)&#125;// [0, 1]// [1, 'asd']// [2, true] Set 只可对值类型的数据进行去重 12345678910let mySet = new Set();mySet.add(1); // Set(1) &#123;1&#125;mySet.add(2); // Set(2) &#123;1, 2&#125;mySet.add(2); // Set(2) &#123;1, 2&#125; // 值类型唯一mySet.add('text'); [...mySet] // [1, 2, 'text']mySet.add(&#123; name:'ha', age:18 &#125;);mySet.add(&#123; name:'ha', age:18 &#125;);[...mySet] // [1, 2, 'text', &#123; name:'ha', age:18 &#125;, &#123; name:'ha', age:18 &#125;] 引用类型去重方案 1Lodash的_.uniqWith()方法 数组的哪些API会改变原数组？ 修改原数组的API有: splice, reverse, fill, copyWithin, sort, push, pop, unshift, shift 不修改原数组的API有: slice, map, forEach, every, filter, reduce, entry, entries, find]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型链思考]]></title>
    <url>%2F2019%2F04%2F08%2F%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[每个函数原型的构造器是它本身。 每个函数的_proto_属性指向它的构造函数的prototype。 原型链继承+深浅拷贝+值类型/引用类型123456789101112131415161718192021function Foo()&#123; this.names = ["Foo"]; // 引用类型 this.hello = 'hello'; // 值类型&#125;function foo()&#123;&#125;foo.prototype = new Foo();var i1 = new foo();i1.names.push("i1");i1.hello = 'world';console.log(i1.names); // ['Foo', 'i1']console.log(i1.hello); // 'world'var i2 = new foo(); console.log(i2.names); // ['Foo', 'i1']console.log(i2.hello); // 'hello'var i3 = new Foo(); console.log(i2.names); // ['Foo']console.log(i2.hello); // 'hello' 原型链示例代码12345678910111213141516171819202122232425262728var Foo = new Function();var foo = new Foo();Foo.__proto__.constructor === FoofalseFoo.__proto__ === Function.prototypetrueFunction.prototype.__proto__ == Object.prototypetrueObject.prototype.__proto__ == nulltrueFoo.prototype.constructor == Footruefoo.__proto__ == Foo.prototypetruefoo.constructor == Footruevar Bar = new Object();Bar.__proto__ == Object.prototypetrueBar.constructor == Objecttrue instanceof12instanceof原理就是一层一层查找 __proto__，如果和 constructor.prototype 相等则返回 true，如果一直没有查找成功则返回 false。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录一次Nginx配置路由经历]]></title>
    <url>%2F2019%2F03%2F19%2F%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1nginx%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[碰到的业务场景：因为在React项目中根目录/，有做重定向，又因为路由采用BrowserRouter，在Nginx的配置中将location / 的目录全部指向index.html，而遇到一个业务场景是要在现有的项目中有需要由一个特定的路由指向一个现成的html页面。期初想法是新建一个location /xxx, root指向对应html,结果发现不管怎样去设置/xxx 的优先级还是会走到项目里的重定向。后来在调研后，发现还是得在location / 下做文章，123456789location / &#123; root /usr/share/nginx/html; index index.html; if ($uri = /xxx) &#123; rewrite ^(.*)$ /$1.html last; break; &#125; try_files $uri $uri/ /index.html;&#125; 当uri碰到需要设置的/xxx路由，做一次rewrite重新匹配，指向目录下的相应html文件，last表示完成该rewrite规则的执行后，停止处理后续rewrite指令集；然后查找匹配改变后URI的新location.]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter如何国际化]]></title>
    <url>%2F2019%2F03%2F06%2FFlutter%E5%A6%82%E4%BD%95%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[要做一个多语言的Flutter应用，有两种引入国际化的方法，一种是自定义Localizations结合Redux实现，可以做到实时切换，另一种是借助第三方工具intl，这里只介绍第一种方式（可结合上一篇状态管理一起学习）。 自定义多语言需要实现LocalizationsDelegate和Localizations，通过Localizations使用locale加载当前delegate。 实现LocalizationsDelegate1234567891011121314151617class DemoLocalizationDelegate extends LocalizationsDelegate&lt;DemoLocalizations&gt; &#123; DemoLocalizationDelegate(); @override &lt;!--支持的语言--&gt; bool isSupported(Locale locale) =&gt; ['en', 'zh'].contains(locale.languageCode); &lt;!--根据locale，创建一个对象用于提供当前locale下的文本显示--&gt; @override Future&lt;DemoLocalizations&gt; load(Locale locale) &#123; return SynchronousFuture&lt;DemoLocalizations&gt;(DemoLocalizations(locale)); &#125; @override bool shouldReload(DemoLocalizationDelegate old) =&gt; false; static DemoLocalizationDelegate delegate = DemoLocalizationDelegate();&#125; DemoLocalizations为一个自定义对象，会根据创建时的Locale， 实现Localizations 1234567891011121314151617class DemoLocalizations &#123; final Locale locale; DemoLocalizations(this.locale); static DemoLocalizations of(BuildContext context) &#123; return Localizations.of&lt;DemoLocalizations&gt;(context, DemoLocalizations); &#125; static Map&lt;String, LocaleBase&gt; _localizedValues = &#123; 'zh': LocaleZHCN(), 'en': LocaleENUS(), &#125;; &lt;!--根据不同 locale.languageCode 加载不同语言对应--&gt; LocaleBase get currentLocalized &#123; return _localizedValues[locale.languageCode]; &#125;&#125; 实现语言实体基类 1234abstract class LocaleBase &#123; String title; String haha;&#125; 实现语言实体 12345678import 'localeBase.dart';class LocaleZHCN extends LocaleBase &#123; @override String title = '您好'; @override String haha = '哈哈';&#125; 此外，还需要创建一个Localizations的Widget，通过StoreBuilder绑定store，然后用Localizations.override包裹所有页面。将Store和Localizations的locale绑定。 1234567891011121314151617181920class LocalizationsWidget extends StatefulWidget &#123; final Widget child; LocalizationsWidget(&#123;this.child&#125;) : super(); @override _LocalizationsWidgetState createState() =&gt; _LocalizationsWidgetState();&#125;class _LocalizationsWidgetState extends State&lt;LocalizationsWidget&gt; &#123; @override Widget build(BuildContext context) &#123; return StoreBuilder&lt;HYXState&gt;(builder: (context, store)&#123; return Localizations.override( child: widget.child, context: context, locale: store.state.locale, ); &#125;); &#125;&#125; 最后，在相应MaterialApp中引入 1234567891011121314151617import 'package:flutter_redux/flutter_redux.dart';@override Widget build(BuildContext context) &#123; return StoreProvider( store: store, child: MaterialApp( localizationsDelegates: [ DemoLocalizationDelegate(), GlobalMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: [store.state.locale], locale: store.state.locale, ), ); &#125; 使用字段 1DemoLocalizations.of(context).currentLocalized.title 切换语言 123456789101112static changeLocale(Store&lt;HYXState&gt; store, int index) &#123; Locale locale = store.state.locale; switch (index) &#123; case 0: locale = Locale('zh', 'CN'); break; case 1: locale = Locale('en', 'US'); break; &#125; store.dispatch(RefreshLocaleAction(locale)); &#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter如何实现状态管理-Redux]]></title>
    <url>%2F2019%2F02%2F25%2FFlutter%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-Redux%2F</url>
    <content type="text"><![CDATA[从前端的角度实现Flutter状态管理自然是用Redux，至于RxDart、BLoC，暂时还未涉及。 简单回忆一下Redux： Store存储和管理全局State Action用于定义一个State变化的行为 Reducer用于根据Action行为产生新State 接下来开始引入并一步步实现： 需要将redux及flutter_redux两个库引入，在pubspec.yaml（相当于package.json）文件中： 123dependencies: redux: ^3.0.0 flutter_redux: ^0.5.2 根据Redux数据流走向，首先定义一个公共Store 1234567class HYXState &#123; ThemeData themeData; Locale locale; &lt;!--构造方法--&gt; HYXState(&#123;this.themeData, this.locale&#125;);&#125;存储了主题颜色和国际化语种 定义Action 123456789class RefreshLocaleAction &#123; final Locale locale; RefreshLocaleAction(this.locale);&#125;class RefreshThemeDataAction &#123; final ThemeData themeData; RefreshThemeDataAction(this.themeData);&#125; 定义Reducer 12345678910111213141516171819202122import 'package:redux/redux.dart';import './actions.dart';&lt;!--通过 flutter_redux 的 combineReducers，创建 Reducer&lt;State&gt; --&gt;final themeDataReducer = combineReducers&lt;ThemeData&gt;([ &lt;!--将Action与处理Action的方法，用TypedReducer绑定--&gt; TypedReducer&lt;ThemeData, RefreshThemeDataAction&gt;(_refresh),]);&lt;!--定义处理Action的方法，返回新State--&gt;ThemeData _refresh(ThemeData themeData, action)&#123; themeData = action.themeData; return themeData;&#125;final localeReducer = combineReducers&lt;Locale&gt;([ TypedReducer&lt;Locale, RefreshLocaleAction&gt;(_changeLocale),]);Locale _changeLocale(Locale locale, RefreshLocaleAction action)&#123; locale = action.locale; return locale;&#125; 需要定义Reducer方法appReducer（自定义方法，用于创建store），将Store中的每一个参数和action绑定起来，数据流为用户每发出一个RefreshLocaleAction，会触发器_refresh方法，之后更新HYXState中的locale 12345678import './reducer.dart';HYXState appReducer(HYXState state, action) &#123; return HYXState( themeData: themeDataReducer(state.themeData, action), locale: localeReducer(state.locale, action), );&#125; 捋清楚好上面的流程后，可以开始实例化store并使用了。类似react-redux提供的Provider包在index.js最外层一样，flutter_redux也提供了StoreProvider用于包括需要的MaterialApp外层，贴出部分重要代码。 123456789101112131415161718192021222324252627import 'package:flutter_redux/flutter_redux.dart';import 'package:redux/redux.dart';import 'package:demo1/redux/store.dart';class Home extends StatefulWidget &#123; @override _HomeState createState() =&gt; new _HomeState();&#125;class _HomeState extends State&lt;Home&gt; &#123; &lt;!--引入自定义的appReducer，将其余初始化state绑定--&gt; final store = Store&lt;HYXState&gt;(appReducer, initialState: HYXState( // themeData: locale: Locale('zh', 'CN'), )); @override Widget build(BuildContext context) &#123; return StoreProvider( store: store, child: MaterialApp( &lt;!--你自己child，可以在其内部使用该store中的state--&gt; ), ); &#125;&#125; flutter_redux提供了一个StoreConnector方法，将其包在子组件外，t通过converter转化store.state的数据，通过builder返回的组件，也可以使用StoreProvider。 123456789101112131415161718192021222324252627282930Widget _itemBuilder(BuildContext context, int index) &#123; return StoreConnector&lt;HYXState, Locale&gt;( converter: (store) =&gt; store.state.locale, builder: (context, locale)&#123; return Container( child: Column( children: &lt;Widget&gt;[ Container( child: Text(locale.toString()), width: 200, ), ], ) ); &#125;, );或：Widget build(BuildContext context) &#123; return StoreBuilder&lt;HYXState&gt;( builder: (context, store) &#123; return Container( child: Column( children: &lt;Widget&gt;[ Text(store.state.locale.toString()), ], ), ); &#125;, ); &#125; 如何触发更新？ 12在StoreProvider中使用时，用：store.dispatch(RefreshLocaleAction(locale)); 至此，Flutter状态管理方案之一Redux基本用法介绍结束，虽然写法比较繁琐，但定义好一套结构后，在复杂业务逻辑中使用起来还是事半功倍的。]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo添加分类标签等选项]]></title>
    <url>%2F2019%2F02%2F22%2Fhexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E6%A0%87%E7%AD%BE%E7%AD%89%E9%80%89%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[直接在主题设置文件内打开tags，categories等选项时，页面确实出现了两个选项按钮，但跳转后没有相应路由地址，需要执行hexo new page tags生成，成功后会提示INFO Created: ~/Desktop/blog/source/tags/index.md，找到该文件，添加type: ‘tags’，如12345---title: tagsdate: 2019-02-22 17:44:17type: &apos;tags&apos;--- 其他类似~]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo个性化配置]]></title>
    <url>%2F2019%2F02%2F21%2Fhexo%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[添加fork me on github点击这里(文字)或者这里(图表)挑选样式,复制代码,将其粘贴到themes/next/layout/_layout.swig文件中的&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面,注意不是里面,并将href改为你的github地址。 添加动态背景就是你现在看到页面的背景线修改themes/next/_config.yml下的canvas_nest: false为canvas_nest: true 修改文章内链接文本样式修改文件themes\next\source\css\_common\components\post\post.styl,添加css样式,如:12345678910.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; .post-body 是为了不影响标题,选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。 修改文章底部tags前的修改模板/themes/next/layout/_macro/post.swig,搜索 rel=”tag”&gt;#,将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;,需重启服务生效 在文章末尾统一添加“本文结束”标记在\themes\next\layout\_macro下新建passage-end-tag.swig文件,并添加以下内容:12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 然后打开\themes\next\layout\_macro\post.swig文件，在post-body之后，post-footer之前添加以下代码(post-footer之前两个div):12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 其实很好理解，在里面插入一个引入的.swig代码。最后再在根目录下的主题配置文件(_config.yml)的末尾添加:123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 侧边栏社交小图标设置打开next主题配置文件themes/next/_config.yml，搜索social_icons，在这里找到相应的图标，并将名字复制在如下位置，保存即可12345678social: GitHub: https://github.com/hyxkiller || github 掘金: https://juejin.im/user/5a708d176fb9a01c9b663da5 || 掘金social_icons: enable: true Github: github-square 掘金: chevron-double-down enable: true为控制icons是否显示属性 在网站底部增加访问量在\themes\next\layout\_partials\footer.swig文件中，搜索copyright，在前面引入一个库：1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 再在当前文件下适当位置添加展示统计数据的代码：12345&lt;div class=&quot;powered-by&quot;&gt; &lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访问量:&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt; 此处，busuanzi_value_site_pv为访问量，busuanzi_value_site_uv为访客数添加后执行hexo d -g，刷新即可 添加热度next主题集成leanCloud，打开/themes/next/layout/_macro/post.swig, 搜索leancloud-visitors-count，在这个span中加℃，然后在/themes/next/languages/zh-Hans.yml,将visitors: 阅读次数换为热度。 添加网站底部字数统计安装hexo-wordcountnpm install hexo-wordcount --save然后在/themes/next/layout/_partials/footer.swig文件尾部加上：1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共 totalcount(site) 字&lt;/span&gt;&lt;/div&gt; 其中totalcount(site)需用双大括号包起来。 设置网站的图标Favicon在EasyIcon中找一张ico图标,或者去别的网站下载或者制作，然后把图标放在/themes/next/source/images里，并且修改主题配置文件themes/next/_config.yml中的favicon为该文件名12345favicon: small: /images/basketball.ico medium: /images/basketball.ico apple_touch_icon: /images/basketball.ico safari_pinned_tab: /images/basketball.ico 实现统计功能安装hexo-wordcountnpm install hexo-wordcount --save然后在主题配置文件中，修改以下配置：1234post_wordcount: item_text: true wordcount: true min2read: true 添加百度统计登录百度统计，按步骤注册账号，之后把生成的baidu_analytics的key添加到/themes/next/_config.yml中的baidu_analytics，部署后查看是否成功。 添加评论功能经过查看next第三方插件的官方文档和多个博客，最终决定采用来必力。 注册账号来必力 将data-uid的值添加到/themes/next/_config.yml中的livere_uid，可在本地查看是否成功。 添加搜索功能安装 hexo-generator-searchdb1npm i hexo-generator-searchdb -S 编辑站点配置文件(_config.yml)，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件(/themes/next/_config.yml)，启用本地搜索功能：12local_search: enable: true 设置首页不显示全文将/themes/next/_config.yml文件中的123auto_excerpt: enable: false length: 150 enable的false改为true，length为设定文章预览文本长度。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引入谷歌统计]]></title>
    <url>%2F2019%2F02%2F20%2F%E5%BC%95%E5%85%A5%E8%B0%B7%E6%AD%8C%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[如何加入谷歌统计 创建或登录到您的 Google Analytics帐号( google.com/analytics) 在 Google Analytics（分析）帐号中设置媒体资源。媒体资源代表您的网站或应用。 如何设置媒体资源？ 登录到谷歌分析后，点击左下角管理，在“帐号”列(第一列)中，来选择要向其添加媒体资源的帐号。如果有多个帐号，可使用搜索框找到所需的帐号。 在“媒体资源”列(第二列)中，点击创建新媒体资源。如果您对相应帐号没有“修改”权限，则看不到创建新媒体资源选项。请检查您是否已 从“帐号”列中选择了正确的帐号。 选择网站或移动应用。如果您选择网站，请跳至第 5 步。如果您选择移动应用，请继续执行第 4 步。 （移动应用）在“跟踪方法”下，选择 Firebase。从菜单中选择一个应用，然后点击关联应用。 输入网站名称或应用名称。如果打算在帐号中跟踪多个应用，请使用非常具体的描述性名称，并在其中包含版本号。方便日后管理。（仅限网站）输入网站网址。如果网址的格式不正确，就无法创建媒体资源。 选择行业类别。 选择报告时区。此时区将用作报告的每日起止时间，而无论数据来自何处。 点击获取跟踪 ID。 在您的媒体资源中设置报告数据视图。数据视图支持显示网站的某一部分跟踪数据，过滤掉其他不重要部分的数据。没有创建视图默认是全部网站数据。 按照说明将跟踪代码添加到您的网站或移动应用。 如何查找跟踪ID？ 登录到您的 Google Analytics（分析）帐号 点击左下角管理 从“帐号”列的菜单中选择一个帐号。 从“媒体资源”列的菜单中选择一个媒体资源。 在“媒体资源”下，点击跟踪信息 &gt; 跟踪代码。跟踪 ID 会显示在页面的顶部。 跟踪代码段 将以下代码段粘贴到网站的每个网页的 标记之后，并且紧挨着该标记放置。将 GA_TRACKING_ID 替换为您自己的 Google Analytics（分析）跟踪 ID： 12345678&lt;script async src="https://www.googletagmanager.com/gtag/js?id=GA_TRACKING_ID"&gt;&lt;/script&gt; &lt;script&gt; window.dataLayer = window.dataLayer || []; function gtag()&#123;dataLayer.push(arguments);&#125; gtag('js', new Date()); gtag('config', 'GA_TRACKING_ID'); &lt;/script&gt; 验证跟踪代码是否正常工作 要验证跟踪代码是否正常工作，请访问您的网站，并检查您的这次访问是否已在实时报告(在左侧面板中，打开实时类别下的概览。)中记录。 设置事件跟踪 设置时间目标 登录到您的 Google Analytics（分析）帐号 点击左下角管理 从“帐号”列的菜单中选择一个帐号。 从“媒体资源”列的菜单中选择一个媒体资源。 从“数据视图”列的菜单中选择一个数据视图。 点击目标&gt;自定义按钮&gt;继续，填写名称(最好是你自己可以区分的，有意义的名字例如：打赏按钮)，点击类型下的事件&gt;继续&gt;填写类别、操作、标签和价值(可选)&gt;保存即可。 设置事件跟踪在你的网页添加如下类似的代码： 1&lt;a onClick="ga('send', 'event', '你填写的类别', '你填写的操作', '你填写的标签','你填写的价值');" href="打赏链接" target="_blank”&gt;打赏&lt;/a&gt; 查看事件追踪报告 左侧面板实时&gt;事件即可查看 设置异常跟踪在您的网站添加如下代码：1ga('send', 'exception', [fieldsObject]); 例如:123456789try &#123; // Runs code that may or may not work. ....&#125; catch(err) &#123; ga('send', 'exception', &#123; 'exDescription': err.message,//可选 标识对异常的说明。 'exFatal': false,//可选 true 表示异常属于严重类型。 &#125;);&#125; 用户识别通过User ID进行用户身份识别注意:USER_ID 值应是一个独一无二的永久性非个人身份字符串，在所有设备上代表对应的用户或已登录帐户。 如果userId是已知的，可以直接获取到，则只需添加如下代码即可： 123ga('create', 'UA-XXXXX-Y', 'auto', &#123; userId: USER_ID&#125;); 如果userId是未知的，需要调用接口才能获取到，那么在获取到userId后执行如下代码： 1ga('set', 'userId', USER_ID); 添加该段代码后必须再设置一个事件向谷歌统计发送数据（参考谷歌统计之设置事件跟踪文章），例如：1ga('send', 'event', 'authentication', 'user-id available'); 停用谷歌统计在网站添加如下代码1window['ga-disable-UA-XXXXX-Y'] = true; 其中的值 UA-XXXXX-Y对应于您要停止跟踪的媒体资源 ID。]]></content>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter请求方案]]></title>
    <url>%2F2019%2F02%2F20%2Fflutter%E8%AF%B7%E6%B1%82%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[请求 pubspec.yaml文件中dev_dependencies下加: http: ^0.11.3+17 1234dev_dependencies: flutter_test: sdk: flutter http: ^0.11.3+17 引入 import ‘package:http/http.dart’ as http; 使用 123456String url = 'http://localhost:9002/tabs';var res = await http.get(url);List list = json.decode(res.body);setState(() &#123; newTitle = list;&#125;);]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter修改应用名及图标]]></title>
    <url>%2F2019%2F02%2F20%2Fflutter%E4%BF%AE%E6%94%B9%E5%BA%94%E7%94%A8%E5%90%8D%E5%8F%8A%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[修改应用名及图标 应用名 Android android -&gt; app -&gt; main -&gt; AndroidManifest.xml下android.label=”名字” iOS ios -&gt; Runner -&gt; info.plist下14行名字 图标 Android android -&gt; app -&gt; main -&gt; res -&gt; mipmap-xxx文件中更换图片 -&gt; AndroidManifest.xml下android.icon=”@mipmap@name” iOS ios -&gt; Runner -&gt; AppIcon.appiconset下更换图片 -&gt; Contents.json修改相应文件名]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter生命周期]]></title>
    <url>%2F2019%2F02%2F20%2Fflutter%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[生命周期 阶段 调用次数 是否支持setState constructor 1 否 initState 1 无效 didChangeDependencies &gt;=1 无效 didUpdateWidget &gt;=1 无效 deactivate &gt;=1 否 dispose 1 否]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter路由]]></title>
    <url>%2F2019%2F02%2F20%2Fflutter%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[路由 静态路由 在相应MaterialApp组件内定义Route，再在需要跳转的地方用以下方法跳转。 1234567891011定义：return MaterialApp( // 命名路由，无法动态传参 routes: &lt;String, WidgetBuilder&gt;&#123; '/search': (BuildContext context) =&gt; SearchWidget(), &#125;,);跳转：onPressed: () =&gt; Navigator.of(context).pushNamed('/search')或onPressed: () =&gt; Navigator.pushNamed(context, '/search') 动态路由 不需要定义 123456789101112131415161718192021222324252627跳转：Navigator.push(context, MaterialPageRoute(builder: (_)&#123; return TestRoute(title: '传参');&#125;));或Navigator.of(context).push(MaterialPageRoute(builder: (_)&#123; return TestRoute(title: '传参');&#125;));接收：接收组件需为动态组件class TestRoute extends StatefulWidget &#123; final String title; // 储存传递过来的参数 TestRoute(&#123;this.title&#125;); // 本页面的构造器，接收传递过来的参数 @override _TestRouteState createState() =&gt; _TestRouteState();&#125;class _TestRouteState extends State&lt;TestRoute&gt; &#123; @override Widget build(BuildContext context) &#123; return Scaffold( appBar: AppBar( title: Text(widget.title), // 使用 ), );&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React项目部署Nginx配置]]></title>
    <url>%2F2019%2F01%2F09%2FReact%E5%A6%82%E4%BD%95%E5%9C%A8Nginx%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[nginx基础命令下载 brew install nginx启动 nginx重启 nginx -s reload关闭 查看主进程号 ps -ef | grep nginx 从容停止 kill -QUIT 主进程号 快速停止 kill -TERM 主进程号 强制停止 kill -9 nginx 配置步骤 把build后的包放到nginx根目录下 修改/usr/local/etc/nginx/nginx.conf文件配置 123456789101112131415161718192021222324252627location / &#123; root build; index index.html index.htm; try_files $uri $uri/ /index.html;&#125;client_max_body_size 2m;location ^~ /api/ &#123; proxy_pass 后端部署地址; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#125;location ~* /.html$ &#123; add_header Cache-Control "no-store, no-cache";&#125;location ~* /.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc|eot|ttf)$ &#123; expires max;&#125;location ~* /.(?:css|js|js/.map)$ &#123; expires max;&#125;error_page 500 502 503 504 /50x.html;location = /50x.html &#123; root html;&#125; 1.root 为根目录默认路径 2.try_files $uri $uri/ /index.html; 因为browserRouter的原因，需要将每个uri指向index.html 3.location ~* /.html$ 为html设置不缓存 4.client_max_body_size限制上传文件大小 5.error_page可以自定义错误页和访问设置 12### location的四种类别 = location = path 优先级最高，但要全路径匹配^~ location ^~ path 优先级第二~ or ~ location ~ path [~正则匹配区分大小写，~不区分大小写] `]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法复杂度]]></title>
    <url>%2F2019%2F01%2F09%2F%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，时间复杂度表示执行的快慢，空间复杂度表示执行的消耗 时间复杂度 只关注循环执行最多的一段代码 加法法则：总复杂度等于量级最大的那段代码的复杂度。 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 常见时间复杂度分析 O(1) 常数阶 O(logn) 对数阶, O(nlogn) 12345678910111213141516function total1(n) &#123; var sum = 0; var i = 1; while (i &lt;= n) &#123; sum += i; i = i * 2; &#125;&#125;function total2(n) &#123; var sum = 0; for (var i = 1; i &lt;= n; i = i * 2) &#123; sum += i; &#125;&#125;2^x = n, x = log2n, O(log2n) O(m+n), O(m*n) 操作数量事例 大O表示法 术语 10 O(1) 常数阶 2logn O(logn) 对数阶 3n+5 O(n) 线性阶 5n^2 + 2n O(n^2) 平方阶 2^n+1 O(2^n) 指数阶 n!+3 O(n!) 阶乘阶 空间复杂度表示算法的存储空间和数据规模的关系。 常见的只有O(1), O(n), O(n^2) 思考题1234567function total(n) &#123; let sum = 0; for (let i = 1; i &lt;= n; i++) &#123; sum += i; &#125; return sum;&#125; 此函数时间复杂度为O(n)，怎么降为O(1)123function total(n)&#123; return n * (n + 1) / 2;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React多页面应用如何配置]]></title>
    <url>%2F2019%2F01%2F09%2FReact%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[修改webpack.config文件主要是entry(入口), output(出口), plugin(插件) entry换为对象，有几个页面加几个数组 1234567891011121314151617entry: &#123; home: [ require.resolve(&apos;./polyfills&apos;), require.resolve(&apos;react-dev-utils/webpackHotDevClient&apos;), path.resolve(paths.appSrc, &quot;index.js&quot;) ], login: [ require.resolve(&apos;./polyfills&apos;), require.resolve(&apos;react-dev-utils/webpackHotDevClient&apos;), path.resolve(paths.appSrc, &quot;login/index.js&quot;) ], register: [ require.resolve(&apos;./polyfills&apos;), require.resolve(&apos;react-dev-utils/webpackHotDevClient&apos;), path.resolve(paths.appSrc, &quot;register/index.js&quot;) ],&#125; output输出文件名加一层 1234output: &#123; filename: &apos;static/js/[name].[hash:8].js&apos;, chunkFilename: &apos;static/js/[name].[hash:8].chunk.js&apos;,&#125; plugin把所有页面都用webpackHtmlPlugin解析 123456789101112131415161718new HtmlWebpackPlugin(&#123; inject: true, chunks: [&apos;home&apos;], template: paths.appHtml, filename: &apos;home.html&apos;&#125;),new HtmlWebpackPlugin(&#123; inject: true, chunks: [&apos;login&apos;], template: paths.appHtml, filename: &apos;login.html&apos;&#125;),new HtmlWebpackPlugin(&#123; inject: true, chunks: [&apos;register&apos;], template: paths.appHtml, filename: &apos;register.html&apos;&#125;),]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React按需加载]]></title>
    <url>%2F2019%2F01%2F09%2FReact%E6%8C%89%E9%9C%80%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[方案1文件代码123456789101112131415161718192021222324252627import React, &#123; Component &#125; from "react";export default function asyncComponent(importComponent) &#123; class AsyncComponent extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; component: null &#125;; &#125; async componentDidMount() &#123; const &#123; default: component &#125; = await importComponent(); this.setState(&#123; component: component &#125;); &#125; render() &#123; const Component = this.state.component; return Component ? &lt;Component &#123;...this.props&#125; /&gt; : null; &#125; &#125; return AsyncComponent;&#125; .babelrc1234567&#123; "presets": [ "react-app", "env", "react-native-stage-0/decorator-support" ]&#125; 装包 都是处理babel的插件1npm i babel-preset-env babel-preset-react-native-stage-0 -D 组件引入12import asyncComponent from 'utils/asyncComponent'const Home = asyncComponent(() =&gt; import('./components/home')); 方案2引入react-loadable 好处：可监听组件加载不到的状态 应用：在不用service-worker的情况下重新部署时，如果用户之前页面没有关，跳路由时，会在服务器找不到相应的chunk文件，此时会通过监听这一状态，返回一个可以自动reload的页面]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深浅拷贝]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[赋值 基本数据类型（string, number, boolean, null, undefined, Symbol）: 赋值,两个变量互不影响 12345let a = 'haha';let b = a;a = 'hahaha';console.log(a); // hahahaconsole.log(b); // haha 引用数据类型(object): 赋址，两个变量具有相同的引用，指向同一个对象，相互之间有影响 123456789101112let a = &#123; name: 'haha', book: &#123; title: 'JS', price: 40 &#125;&#125;let b = a;a.name = 'hahaha';a.book.price = 50;console.log(a); // &#123;name: 'hahaha', book: &#123;title: 'JS', price: 50&#125;&#125;console.log(b); // &#123;name: 'hahaha', book: &#123;title: 'JS', price: 50&#125;&#125; 浅拷贝 概念创建一个对象，有原始对象属性值的一份精确拷贝。基本类型: 拷贝值引用类型: 拷贝内存地址，其中一个对象改变了地址，会影响到另一个对象 场景 Object.assign() 123456789101112let a = &#123; name: 'haha', book: &#123; title: 'JS', price: 40 &#125;&#125;let b = Object.assign(&#123;&#125;, a);a.name = 'hahaha';a.book.price = 50;console.log(a); // &#123;name: 'hahaha', book: &#123;title: 'JS', price: 50&#125;&#125;console.log(b); // &#123;name: 'haha', book: &#123;title: 'JS', price: 50&#125;&#125; Spread展开运算符同Object.assign() slice()slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。123456let a = [0, "1", [2, 3]];let b = a.slice(1);a[1] = "99";a[2][0] = 4;console.log(a); // [0, "99", [4, 3]]console.log(b); // ["1", [4, 3]] 深拷贝深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。 使用场景 JSON.parse(JSON.stringfy(object)) 123456789101112let a = &#123; name: "haha", book: &#123; title: "JS", price: 45 &#125;&#125;let b = JSON.parse(JSON.stringify(a));a.name = 'change';a.book.price = 100;console.log(a); // &#123;name: 'change', book: &#123;title: 'JS', price: 100&#125;&#125;console.log(b); // &#123;name: 'haha', book: &#123;title: 'JS', price: 45&#125;&#125; 问题 undefined, Symbol, 函数，会直接忽略 12345678let obj = &#123; name: 'haha', a: undefined, b: Symbol('haha'), c: function() &#123;&#125;&#125;let b = JSON.parse(JSON.stringfy(obj));console.log(b); // &#123;name: 'haha'&#125; 循环引用，会报错 new Date情况下，转换结果不正确 不能处理正则 – 和原数据是否指向同一对象 第一层数据为基本数据类型 原数据中包含子对象 赋值 是 改变会使原数据一同改变 改变会使原数据一同改变 浅拷贝 是 改变不会使原数据一同改变 改变会使原数据一同改变 深拷贝 是 改变不会使原数据一同改变 改变不会使原数据一同改变]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
